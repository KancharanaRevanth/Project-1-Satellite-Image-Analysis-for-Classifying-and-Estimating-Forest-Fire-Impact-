# -*- coding: utf-8 -*-
"""ForestFire.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KbdTQcl-EEJ99-kseAuElf6f74ZF62rv
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install timm torch torchvision resnest pandas numpy scikit-learn matplotlib seaborn folium geopandas rasterio

"""**LOAD AND PREPROCESS DATA**"""

# Use the first 100,000 rows
sampled_data = data.iloc[:1500]

# Extract features and labels from the sampled data
coordinates = sampled_data[['latitude', 'longitude']].values
labels = sampled_data['fire_label'].values

# Train-Test Split
X_train, X_test, y_train, y_test = train_test_split(coordinates, labels, test_size=0.2, random_state=42)

print(f"Training data shape: {X_train.shape}, {y_train.shape}")
print(f"Testing data shape: {X_test.shape}, {y_test.shape}")

"""**SPLIT DATA**"""

from sklearn.preprocessing import StandardScaler

# Normalize the coordinates (latitude, longitude)
scaler = StandardScaler()
coordinates = scaler.fit_transform(sampled_data[['latitude', 'longitude']].values)

# Extract labels
labels = sampled_data['fire_label'].values

# Train-Test Split
X_train, X_test, y_train, y_test = train_test_split(coordinates, labels, test_size=0.2, random_state=42)

print(f"Training data shape: {X_train.shape}, {y_train.shape}")
print(f"Testing data shape: {X_test.shape}, {y_test.shape}")

"""**PREPARING DATA FOR PYTORCH**"""

import torch
from torch.utils.data import Dataset, DataLoader
import numpy as np
import pandas as pd

class FireImageDataset(Dataset):
    def __init__(self, X_images, y_class, y_regress):
        self.X = torch.tensor(X_images, dtype=torch.float32)
        self.y_class = torch.tensor(y_class.values, dtype=torch.long)  # Long type for CrossEntropyLoss
        self.y_regress = torch.tensor(y_regress.values, dtype=torch.float32)

    def __len__(self):
        return len(self.X)

    def __getitem__(self, idx):
        return self.X[idx], self.y_class[idx], self.y_regress[idx]

# Create datasets and dataloaders
train_dataset = FireImageDataset(X_images[:len(X_train)], y_class_train, y_regress_train)
val_dataset = FireImageDataset(X_images[len(X_train):], y_class_val, y_regress_val)

train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=32, shuffle=False)

# Initialize lists to store predictions and the corresponding indices
y_class_pred, y_regress_pred, all_indices = [], [], []

"""**DEFINE RESNEST MODEL**"""

import timm
import torch.nn as nn

# Define ResNeSt model
model = timm.create_model('resnest50d', pretrained=True, num_classes=2)  # Binary classification

# Add a regression head
class FireModel(nn.Module):
    def __init__(self, base_model):
        super(FireModel, self).__init__()
        self.base_model = base_model
        self.fc_regress = nn.Linear(2, 1)  # Regression head for fire intensity

    def forward(self, x):
        class_output = self.base_model(x)  # Classification
        regress_output = self.fc_regress(class_output)  # Regression
        return class_output, regress_output

# Wrap the model
model = FireModel(model).to(device)

"""**DEFINING THE TRAINING FUNCTION FOR THE MODEL**"""

import torch.optim as optim

# Define loss functions
criterion_class = nn.CrossEntropyLoss()  # For classification
criterion_regress = nn.MSELoss()  # For regression

# Define optimizer
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training loop
def train_model(model, train_loader, val_loader, epochs=10):
    for epoch in range(epochs):
        model.train()
        train_loss = 0

        for X_batch, y_class_batch, y_regress_batch in train_loader:
            X_batch, y_class_batch, y_regress_batch = (
                X_batch.to(device),
                y_class_batch.to(device),
                y_regress_batch.to(device),
            )

            # Forward pass
            class_preds, regress_preds = model(X_batch)
            loss_class = criterion_class(class_preds, y_class_batch)  # Classification loss
            loss_regress = criterion_regress(regress_preds.squeeze(), y_regress_batch)  # Regression loss
            loss = loss_class + loss_regress

            # Backward pass
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            train_loss += loss.item()

        print(f"Epoch {epoch+1}/{epochs}, Loss: {train_loss/len(train_loader):.4f}")

"""**TRAINING THE MODEL**"""

# Train the model
train_model(model, train_loader, val_loader, epochs=10)

"""**VISUALIZING FIRE AREAS**"""

# Set model to evaluation mode
model.eval()

# Perform inference
with torch.no_grad():
    for i, (X_batch, y_class_batch, y_regress_batch) in enumerate(val_loader):
        X_batch = X_batch.to(device)
        class_output, regress_output = model(X_batch)

        # Get predictions for class and regression
        y_class_pred.extend(torch.argmax(class_output, dim=1).cpu().numpy())  # Class
        y_regress_pred.extend(regress_output.cpu().numpy())  # Intensity

        # Collect indices corresponding to the batch (this is crucial for matching predictions)
        start_idx = i * val_loader.batch_size
        end_idx = start_idx + X_batch.size(0)
        all_indices.extend(range(start_idx, end_idx))

# Convert predictions to numpy arrays
y_class_pred = np.array(y_class_pred)
y_regress_pred = np.array(y_regress_pred)
all_indices = np.array(all_indices)

# Create a DataFrame with the full validation set and predictions
fire_data = pd.DataFrame(
    X_images[all_indices, :2],  # Using the collected indices to select data
    columns=['latitude', 'longitude']
)
fire_data['fire_class'] = y_class_pred
fire_data['frp'] = y_regress_pred

# Filter predicted fire locations (you can change the condition for fire_class as per your model's output)
fire_data = fire_data[fire_data['fire_class'] == 1]  # Fire class is assumed to be 1

# Visualize on a map if fire predictions exist
if fire_data.empty:
    print("No fire data available to plot. Check model predictions.")
else:
    m = folium.Map(
        location=[fire_data['latitude'].mean(), fire_data['longitude'].mean()],
        zoom_start=6
    )
    for _, row in fire_data.iterrows():
        folium.CircleMarker(
            location=[row['latitude'], row['longitude']],
            radius=5,
            color='red',
            fill=True,
            fill_color='red',
            popup=f"Intensity: {row['frp']:.2f}"  # Format intensity
        ).add_to(m)
    # Display the map
    m

"""**DISPLAYING SATELLITE IMAGES**"""

import matplotlib.pyplot as plt

# Placeholder function for displaying satellite image
def show_satellite_image(lat, lon, title="Satellite Image"):
    plt.figure(figsize=(8, 8))
    plt.title(title)
    plt.imshow([[1, 0], [0, 1]], cmap="hot", interpolation="nearest")  # Placeholder heatmap
    plt.scatter(1, 1, color='red', label='Fire Location')  # Fire marker
    plt.legend()
    plt.show()

# Example for the first fire location
lat, lon = fire_data.iloc[0]['latitude'], fire_data.iloc[0]['longitude']
show_satellite_image(lat, lon, title="Fire Area Satellite Image")

"""**SAVING THE MODEL**"""

torch.save(model.state_dict(), 'fire_model.pth')